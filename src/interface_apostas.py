#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Interface Gr√°fica para An√°lise de Apostas Esportivas
Sistema completo para c√°lculo de probabilidades baseado em estat√≠sticas de gols
Integrado com API SofaScore para busca autom√°tica de times
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import json
import math
from datetime import datetime
import os
import sys
import threading

# Adicionar pasta api ao path para importar m√≥dulos
pasta_atual = os.path.dirname(os.path.abspath(__file__))
pasta_pai = os.path.dirname(pasta_atual)
pasta_api = os.path.join(pasta_pai, 'api')
if pasta_api not in sys.path:
    sys.path.insert(0, pasta_api)

from api.sofascore_api import SofaScoreAPI

class CalculadoraApostasGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Sistema de An√°lise de Apostas - Calculadora Avan√ßada")
        self.root.geometry("1000x700")
        
        # Dados dos times e apostas
        self.times_database = {}
        self.apostas_ativas = []
        
        # Integra√ß√£o com API SofaScore
        self.api = SofaScoreAPI()
        
        # Configurar estilo
        self.setup_styles()
        
        # Criar interface
        self.create_widgets()
        
        # Carregar dados salvos
        self.carregar_dados()
    
    def setup_styles(self):
        """Configura estilos da interface"""
        style = ttk.Style()
        style.configure('Title.TLabel', font=('Arial', 14, 'bold'))
        style.configure('Subtitle.TLabel', font=('Arial', 10, 'bold'))
        style.configure('Success.TLabel', foreground='green', font=('Arial', 10, 'bold'))
        style.configure('Warning.TLabel', foreground='red', font=('Arial', 10, 'bold'))
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Notebook para abas
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Aba 1: Busca de Times (API)
        self.create_busca_api_tab()
        
        # Aba 2: Cadastro de Times
        self.create_cadastro_tab()
        
        # Aba 3: An√°lise de Confrontos
        self.create_analise_tab()
        
        # Aba 4: Apostas e M√∫ltiplas
        self.create_apostas_tab()
        
        # Aba 5: Hist√≥rico e Estat√≠sticas
        self.create_historico_tab()
    
    def create_busca_api_tab(self):
        """Cria a aba de busca de times via API SofaScore"""
        self.tab_busca_api = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_busca_api, text="üîç Buscar Times (API)")
        
        # T√≠tulo
        ttk.Label(self.tab_busca_api, text="Busca de Times via SofaScore API", style='Title.TLabel').pack(pady=10)
        
        # Frame principal
        main_frame = ttk.Frame(self.tab_busca_api)
        main_frame.pack(fill='both', expand=True, padx=20)
        
        # Frame de busca
        busca_frame = ttk.LabelFrame(main_frame, text="Buscar Time", padding=15)
        busca_frame.pack(fill='x', pady=10)
        
        # Campo de busca
        ttk.Label(busca_frame, text="Nome do Time:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.entry_busca_time = ttk.Entry(busca_frame, width=30, font=('Arial', 12))
        self.entry_busca_time.grid(row=0, column=1, padx=5, pady=5)
        self.entry_busca_time.bind('<Return>', lambda event: self.buscar_times_api())
        
        # Bot√µes de a√ß√£o
        btn_frame = ttk.Frame(busca_frame)
        btn_frame.grid(row=0, column=2, padx=10, pady=5)
        
        self.btn_buscar = ttk.Button(btn_frame, text="üîç Buscar", command=self.buscar_times_api)
        self.btn_buscar.pack(side='left', padx=5)
        
        ttk.Button(btn_frame, text="üîÑ Limpar", command=self.limpar_busca).pack(side='left', padx=5)
        
        # Label de status
        self.label_status_busca = ttk.Label(busca_frame, text="Digite o nome de um time e clique em Buscar", 
                                           style='Subtitle.TLabel')
        self.label_status_busca.grid(row=1, column=0, columnspan=3, pady=10)
        
        # Frame de resultados
        resultados_frame = ttk.LabelFrame(main_frame, text="Resultados da Busca", padding=10)
        resultados_frame.pack(fill='both', expand=True, pady=10)
        
        # Treeview para mostrar resultados
        columns = ('Nome', 'Pa√≠s', 'Liga', 'Gols/Partida', 'Gols Sofridos', 'Est√°dio', 'Popularidade')
        self.tree_busca = ttk.Treeview(resultados_frame, columns=columns, show='headings', height=12)
        
        # Configurar colunas
        column_widths = {'Nome': 150, 'Pa√≠s': 80, 'Liga': 120, 'Gols/Partida': 100, 
                        'Gols Sofridos': 100, 'Est√°dio': 150, 'Popularidade': 100}
        
        for col in columns:
            self.tree_busca.heading(col, text=col)
            self.tree_busca.column(col, width=column_widths.get(col, 100), anchor='center')
        
        # Scrollbars
        scrollbar_v = ttk.Scrollbar(resultados_frame, orient='vertical', command=self.tree_busca.yview)
        scrollbar_h = ttk.Scrollbar(resultados_frame, orient='horizontal', command=self.tree_busca.xview)
        self.tree_busca.configure(yscrollcommand=scrollbar_v.set, xscrollcommand=scrollbar_h.set)
        
        # Grid layout para scrollbars
        self.tree_busca.grid(row=0, column=0, sticky='nsew')
        scrollbar_v.grid(row=0, column=1, sticky='ns')
        scrollbar_h.grid(row=1, column=0, sticky='ew')
        
        resultados_frame.grid_rowconfigure(0, weight=1)
        resultados_frame.grid_columnconfigure(0, weight=1)
        
        # Bot√µes de a√ß√£o para resultados
        acoes_frame = ttk.Frame(resultados_frame)
        acoes_frame.grid(row=2, column=0, columnspan=2, pady=10, sticky='ew')
        
        self.btn_adicionar_selecionado = ttk.Button(acoes_frame, text="‚ûï Adicionar Time Selecionado", 
                                                   command=self.adicionar_time_da_busca, state='disabled')
        self.btn_adicionar_selecionado.pack(side='left', padx=5)
        
        ttk.Button(acoes_frame, text="üìã Ver Detalhes", command=self.ver_detalhes_time).pack(side='left', padx=5)
        
        # Bind para sele√ß√£o
        self.tree_busca.bind('<<TreeviewSelect>>', self.on_selecao_busca)
        
        # Frame de informa√ß√µes da API
        info_frame = ttk.LabelFrame(main_frame, text="‚ÑπÔ∏è Informa√ß√µes", padding=10)
        info_frame.pack(fill='x', pady=5)
        
        info_text = """
üåê Esta funcionalidade busca times reais da base de dados do SofaScore
üìä Os dados incluem estat√≠sticas estimadas baseadas na liga do time
üîÑ As informa√ß√µes s√£o atualizadas automaticamente durante a busca
‚ö° Use esta op√ß√£o para adicionar times rapidamente com dados precisos
        """
        ttk.Label(info_frame, text=info_text.strip(), justify='left').pack(anchor='w')
    
    def create_cadastro_tab(self):
        """Cria a aba de cadastro de times"""
        self.tab_cadastro = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_cadastro, text="Cadastro de Times")
        
        # T√≠tulo
        ttk.Label(self.tab_cadastro, text="Cadastro de Times", style='Title.TLabel').pack(pady=10)
        
        # Frame principal
        main_frame = ttk.Frame(self.tab_cadastro)
        main_frame.pack(fill='both', expand=True, padx=20)
        
        # Frame de entrada
        entrada_frame = ttk.LabelFrame(main_frame, text="Adicionar Novo Time", padding=15)
        entrada_frame.pack(fill='x', pady=10)
        
        # Grid para organizar campos
        ttk.Label(entrada_frame, text="Nome do Time:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.entry_nome = ttk.Entry(entrada_frame, width=25)
        self.entry_nome.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(entrada_frame, text="Gols por Partida:").grid(row=0, column=2, sticky='w', padx=5, pady=5)
        self.entry_gols_marcados = ttk.Entry(entrada_frame, width=15)
        self.entry_gols_marcados.grid(row=0, column=3, padx=5, pady=5)
        
        ttk.Label(entrada_frame, text="Gols Sofridos por Partida:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.entry_gols_sofridos = ttk.Entry(entrada_frame, width=15)
        self.entry_gols_sofridos.grid(row=1, column=1, padx=5, pady=5)
        
        ttk.Label(entrada_frame, text="Liga/Campeonato:").grid(row=1, column=2, sticky='w', padx=5, pady=5)
        self.entry_liga = ttk.Entry(entrada_frame, width=20)
        self.entry_liga.grid(row=1, column=3, padx=5, pady=5)
        
        # Bot√µes
        btn_frame = ttk.Frame(entrada_frame)
        btn_frame.grid(row=2, column=0, columnspan=4, pady=15)
        
        ttk.Button(btn_frame, text="Adicionar Time", 
                  command=self.adicionar_time).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="Limpar Campos", 
                  command=self.limpar_campos_cadastro).pack(side='left', padx=5)
        
        # Lista de times cadastrados
        lista_frame = ttk.LabelFrame(main_frame, text="Times Cadastrados", padding=10)
        lista_frame.pack(fill='both', expand=True, pady=10)
        
        # Treeview para mostrar times
        columns = ('Nome', 'Gols/Partida', 'Gols Sofridos/Partida', 'Liga', 'For√ßa Ofensiva', 'For√ßa Defensiva')
        self.tree_times = ttk.Treeview(lista_frame, columns=columns, show='headings', height=15)
        
        for col in columns:
            self.tree_times.heading(col, text=col)
            self.tree_times.column(col, width=120, anchor='center')
        
        # Scrollbar para a tabela
        scrollbar_times = ttk.Scrollbar(lista_frame, orient='vertical', command=self.tree_times.yview)
        self.tree_times.configure(yscrollcommand=scrollbar_times.set)
        
        self.tree_times.pack(side='left', fill='both', expand=True)
        scrollbar_times.pack(side='right', fill='y')
        
        # Bot√µes de a√ß√£o
        btn_actions_frame = ttk.Frame(lista_frame)
        btn_actions_frame.pack(fill='x', pady=5)
        
        ttk.Button(btn_actions_frame, text="Remover Time Selecionado", 
                  command=self.remover_time).pack(side='left', padx=5)
        ttk.Button(btn_actions_frame, text="Editar Time", 
                  command=self.editar_time).pack(side='left', padx=5)
        ttk.Button(btn_actions_frame, text="Exportar Dados", 
                  command=self.exportar_dados).pack(side='right', padx=5)
    
    def create_analise_tab(self):
        """Cria a aba de an√°lise de confrontos"""
        self.tab_analise = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_analise, text="An√°lise de Confrontos")
        
        ttk.Label(self.tab_analise, text="An√°lise de Confrontos", style='Title.TLabel').pack(pady=10)
        
        main_frame = ttk.Frame(self.tab_analise)
        main_frame.pack(fill='both', expand=True, padx=20)
        
        # Frame de sele√ß√£o
        selecao_frame = ttk.LabelFrame(main_frame, text="Selecionar Confronto", padding=15)
        selecao_frame.pack(fill='x', pady=10)
        
        # Comboboxes para sele√ß√£o de times
        ttk.Label(selecao_frame, text="Time A (Casa):").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.combo_time_a = ttk.Combobox(selecao_frame, width=25, state="readonly")
        self.combo_time_a.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(selecao_frame, text="Time B (Visitante):").grid(row=0, column=2, sticky='w', padx=5, pady=5)
        self.combo_time_b = ttk.Combobox(selecao_frame, width=25, state="readonly")
        self.combo_time_b.grid(row=0, column=3, padx=5, pady=5)
        
        # Odds
        ttk.Label(selecao_frame, text="Odd Vit√≥ria A:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.entry_odd_a = ttk.Entry(selecao_frame, width=15)
        self.entry_odd_a.grid(row=1, column=1, padx=5, pady=5)
        
        ttk.Label(selecao_frame, text="Odd Empate:").grid(row=1, column=2, sticky='w', padx=5, pady=5)
        self.entry_odd_empate = ttk.Entry(selecao_frame, width=15)
        self.entry_odd_empate.grid(row=1, column=3, padx=5, pady=5)
        
        ttk.Label(selecao_frame, text="Odd Vit√≥ria B:").grid(row=2, column=0, sticky='w', padx=5, pady=5)
        self.entry_odd_b = ttk.Entry(selecao_frame, width=15)
        self.entry_odd_b.grid(row=2, column=1, padx=5, pady=5)
        
        # Fator casa (checkbox) com callback para atualizar indicador
        self.var_fator_casa = tk.BooleanVar()
        self.var_fator_casa.set(True)  # Ativado por padr√£o
        self.check_fator_casa = ttk.Checkbutton(
            selecao_frame, 
            text="Aplicar Vantagem de Casa (15%)", 
            variable=self.var_fator_casa,
            command=self.atualizar_indicador_fator_casa
        )
        self.check_fator_casa.grid(row=2, column=2, columnspan=2, sticky='w', padx=5, pady=5)
        
        # Indicador visual do status do fator casa
        self.label_status_casa = ttk.Label(selecao_frame, text="‚úÖ Vantagem de casa ATIVADA", 
                                          style='Success.TLabel')
        self.label_status_casa.grid(row=3, column=2, columnspan=2, sticky='w', padx=5, pady=5)
        
        # Bot√£o calcular
        ttk.Button(selecao_frame, text="Calcular Probabilidades", 
                  command=self.calcular_confronto).grid(row=4, column=1, columnspan=2, pady=15)
        
        # Frame de resultados
        resultados_frame = ttk.LabelFrame(main_frame, text="Resultados da An√°lise", padding=15)
        resultados_frame.pack(fill='both', expand=True, pady=10)
        
        # √Årea de texto para resultados
        self.text_resultados = scrolledtext.ScrolledText(resultados_frame, height=20, width=100)
        self.text_resultados.pack(fill='both', expand=True)
    
    def create_apostas_tab(self):
        """Cria a aba de apostas e m√∫ltiplas"""
        self.tab_apostas = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_apostas, text="Apostas e M√∫ltiplas")
        
        ttk.Label(self.tab_apostas, text="Sistema de Apostas", style='Title.TLabel').pack(pady=10)
        
        main_frame = ttk.Frame(self.tab_apostas)
        main_frame.pack(fill='both', expand=True, padx=20)
        
        # Frame esquerdo - Adicionar apostas
        left_frame = ttk.LabelFrame(main_frame, text="Adicionar Aposta", padding=15)
        left_frame.pack(side='left', fill='both', expand=True, padx=5)
        
        # Sele√ß√£o do confronto
        ttk.Label(left_frame, text="Time A:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.combo_aposta_time_a = ttk.Combobox(left_frame, width=20, state="readonly")
        self.combo_aposta_time_a.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(left_frame, text="Time B:").grid(row=0, column=2, sticky='w', padx=5, pady=5)
        self.combo_aposta_time_b = ttk.Combobox(left_frame, width=20, state="readonly")
        self.combo_aposta_time_b.grid(row=0, column=3, padx=5, pady=5)
        
        # Tipo de aposta
        ttk.Label(left_frame, text="Tipo de Aposta:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.combo_tipo_aposta = ttk.Combobox(left_frame, values=["Vit√≥ria A", "Empate", "Vit√≥ria B"], 
                                             state="readonly", width=15)
        self.combo_tipo_aposta.grid(row=1, column=1, padx=5, pady=5)
        
        # Odd da aposta
        ttk.Label(left_frame, text="Odd:").grid(row=1, column=2, sticky='w', padx=5, pady=5)
        self.entry_aposta_odd = ttk.Entry(left_frame, width=15)
        self.entry_aposta_odd.grid(row=1, column=3, padx=5, pady=5)
        
        # Valor da aposta
        ttk.Label(left_frame, text="Valor da Aposta (R$):").grid(row=2, column=0, sticky='w', padx=5, pady=5)
        self.entry_valor_aposta = ttk.Entry(left_frame, width=15)
        self.entry_valor_aposta.grid(row=2, column=1, padx=5, pady=5)
        
        # Bot√µes
        btn_frame = ttk.Frame(left_frame)
        btn_frame.grid(row=3, column=0, columnspan=4, pady=15)
        
        ttk.Button(btn_frame, text="Calcular Aposta Simples", 
                  command=self.calcular_aposta_simples).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="Adicionar √† M√∫ltipla", 
                  command=self.adicionar_multipla).pack(side='left', padx=5)
        
        # Frame direito - Apostas ativas
        right_frame = ttk.LabelFrame(main_frame, text="Apostas Ativas", padding=15)
        right_frame.pack(side='right', fill='both', expand=True, padx=5)
        
        # Lista de apostas m√∫ltiplas
        columns_apostas = ('Confronto', 'Tipo', 'Odd', 'Probabilidade')
        self.tree_apostas = ttk.Treeview(right_frame, columns=columns_apostas, show='headings', height=10)
        
        for col in columns_apostas:
            self.tree_apostas.heading(col, text=col)
            self.tree_apostas.column(col, width=100, anchor='center')
        
        self.tree_apostas.pack(fill='both', expand=True)
        
        # C√°lculo da m√∫ltipla
        multipla_frame = ttk.Frame(right_frame)
        multipla_frame.pack(fill='x', pady=10)
        
        ttk.Label(multipla_frame, text="Valor Total (R$):").pack(side='left')
        self.entry_valor_multipla = ttk.Entry(multipla_frame, width=15)
        self.entry_valor_multipla.pack(side='left', padx=5)
        
        ttk.Button(multipla_frame, text="Calcular M√∫ltipla", 
                  command=self.calcular_multipla).pack(side='left', padx=5)
        ttk.Button(multipla_frame, text="Limpar Lista", 
                  command=self.limpar_apostas).pack(side='left', padx=5)
        
        # Resultados
        self.label_resultado_multipla = ttk.Label(right_frame, text="", style='Success.TLabel')
        self.label_resultado_multipla.pack(pady=10)
    
    def create_historico_tab(self):
        """Cria a aba de hist√≥rico e estat√≠sticas"""
        self.tab_historico = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_historico, text="Hist√≥rico & Stats")
        
        ttk.Label(self.tab_historico, text="Hist√≥rico e Estat√≠sticas", style='Title.TLabel').pack(pady=10)
        
        # √Årea de texto para estat√≠sticas
        self.text_historico = scrolledtext.ScrolledText(self.tab_historico, height=30, width=120)
        self.text_historico.pack(fill='both', expand=True, padx=20, pady=10)
        
        # Bot√µes
        btn_frame = ttk.Frame(self.tab_historico)
        btn_frame.pack(pady=10)
        
        ttk.Button(btn_frame, text="Atualizar Estat√≠sticas", 
                  command=self.atualizar_estatisticas).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="Exportar Relat√≥rio", 
                  command=self.exportar_relatorio).pack(side='left', padx=5)
    
    def atualizar_comboboxes(self):
        """Atualiza as listas de times nos comboboxes"""
        times = list(self.times_database.keys())
        
        # Atualizar comboboxes da aba de an√°lise
        self.combo_time_a['values'] = times
        self.combo_time_b['values'] = times
        
        # Atualizar comboboxes da aba de apostas
        self.combo_aposta_time_a['values'] = times
        self.combo_aposta_time_b['values'] = times
    
    def adicionar_time(self):
        """Adiciona um novo time ao banco de dados"""
        try:
            nome = self.entry_nome.get().strip()
            gols_marcados = float(self.entry_gols_marcados.get().replace(',', '.'))
            gols_sofridos = float(self.entry_gols_sofridos.get().replace(',', '.'))
            liga = self.entry_liga.get().strip() or "N√£o informado"
            
            if not nome:
                messagebox.showerror("Erro", "Nome do time √© obrigat√≥rio!")
                return
            
            if nome in self.times_database:
                if not messagebox.askyesno("Confirma√ß√£o", f"Time {nome} j√° existe. Deseja atualizar?"):
                    return
            
            # Calcular for√ßas (assumindo m√©dia da liga = 1.2)
            media_liga = 1.2
            forca_ofensiva = gols_marcados / media_liga
            forca_defensiva = gols_sofridos / media_liga
            
            self.times_database[nome] = {
                'gols_marcados': gols_marcados,
                'gols_sofridos': gols_sofridos,
                'liga': liga,
                'forca_ofensiva': forca_ofensiva,
                'forca_defensiva': forca_defensiva,
                'data_cadastro': datetime.now().isoformat()
            }
            
            self.atualizar_lista_times()
            self.atualizar_comboboxes()
            self.limpar_campos_cadastro()
            self.salvar_dados()
            
            messagebox.showinfo("Sucesso", f"Time {nome} adicionado com sucesso!")
            
        except ValueError:
            messagebox.showerror("Erro", "Por favor, insira valores num√©ricos v√°lidos para os gols!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar time: {str(e)}")
    
    def atualizar_lista_times(self):
        """Atualiza a lista de times na interface"""
        # Limpar lista atual
        for item in self.tree_times.get_children():
            self.tree_times.delete(item)
        
        # Adicionar times
        for nome, dados in self.times_database.items():
            self.tree_times.insert('', 'end', values=(
                nome,
                f"{dados['gols_marcados']:.2f}",
                f"{dados['gols_sofridos']:.2f}",
                dados['liga'],
                f"{dados['forca_ofensiva']:.2f}",
                f"{dados['forca_defensiva']:.2f}"
            ))
    
    def limpar_campos_cadastro(self):
        """Limpa os campos de cadastro"""
        self.entry_nome.delete(0, tk.END)
        self.entry_gols_marcados.delete(0, tk.END)
        self.entry_gols_sofridos.delete(0, tk.END)
        self.entry_liga.delete(0, tk.END)
    
    def atualizar_indicador_fator_casa(self):
        """Atualiza o indicador visual do status do fator casa"""
        if self.var_fator_casa.get():
            self.label_status_casa.config(
                text="‚úÖ Vantagem de casa ATIVADA", 
                style='Success.TLabel'
            )
        else:
            self.label_status_casa.config(
                text="‚ùå Vantagem de casa DESATIVADA", 
                style='Warning.TLabel'
            )
    
    def remover_time(self):
        """Remove o time selecionado"""
        selected = self.tree_times.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione um time para remover!")
            return
        
        item = self.tree_times.item(selected[0])
        nome_time = item['values'][0]
        
        if messagebox.askyesno("Confirma√ß√£o", f"Deseja remover o time {nome_time}?"):
            del self.times_database[nome_time]
            self.atualizar_lista_times()
            self.atualizar_comboboxes()
            self.salvar_dados()
            messagebox.showinfo("Sucesso", f"Time {nome_time} removido!")
    
    def calcular_gols_esperados(self, time_a_dados, time_b_dados, aplicar_fator_casa=True):
        """
        Calcula gols esperados usando o modelo melhorado
        
        Args:
            time_a_dados: Dados do time A (casa)
            time_b_dados: Dados do time B (visitante)
            aplicar_fator_casa: Boolean se deve aplicar vantagem de casa (15%)
        """
        media_liga = 1.2
        fator_casa = 1.15 if aplicar_fator_casa else 1.0
        
        # For√ßas j√° calculadas
        forca_of_a = time_a_dados['forca_ofensiva']
        forca_def_a = time_a_dados['forca_defensiva']
        forca_of_b = time_b_dados['forca_ofensiva']
        forca_def_b = time_b_dados['forca_defensiva']
        
        # Gols esperados com ou sem fator casa
        gols_esperados_a = forca_of_a * forca_def_b * media_liga * fator_casa
        gols_esperados_b = forca_of_b * forca_def_a * media_liga
        
        return gols_esperados_a, gols_esperados_b
    
    def calcular_probabilidades_poisson(self, gols_esperados_a, gols_esperados_b, max_gols=6):
        """Calcula probabilidades usando distribui√ß√£o de Poisson"""
        prob_vitoria_a = 0
        prob_empate = 0
        prob_vitoria_b = 0
        
        for gols_a in range(max_gols + 1):
            for gols_b in range(max_gols + 1):
                # F√≥rmula de Poisson: P(X=k) = (Œª^k * e^(-Œª)) / k!
                prob_a = (gols_esperados_a ** gols_a * math.exp(-gols_esperados_a)) / math.factorial(gols_a)
                prob_b = (gols_esperados_b ** gols_b * math.exp(-gols_esperados_b)) / math.factorial(gols_b)
                prob_combinada = prob_a * prob_b
                
                if gols_a > gols_b:
                    prob_vitoria_a += prob_combinada
                elif gols_a == gols_b:
                    prob_empate += prob_combinada
                else:
                    prob_vitoria_b += prob_combinada
        
        return prob_vitoria_a, prob_empate, prob_vitoria_b
    
    def calcular_confronto(self):
        """Calcula e exibe a an√°lise completa do confronto"""
        try:
            time_a = self.combo_time_a.get()
            time_b = self.combo_time_b.get()
            
            if not time_a or not time_b:
                messagebox.showwarning("Aviso", "Selecione ambos os times!")
                return
            
            if time_a == time_b:
                messagebox.showwarning("Aviso", "Selecione times diferentes!")
                return
            
            # Obter dados dos times
            dados_a = self.times_database[time_a]
            dados_b = self.times_database[time_b]
            
            # Obter configura√ß√£o do fator casa
            aplicar_fator_casa = self.var_fator_casa.get()
            
            # Calcular gols esperados
            gols_esp_a, gols_esp_b = self.calcular_gols_esperados(dados_a, dados_b, aplicar_fator_casa)
            
            # Calcular probabilidades
            prob_a, prob_empate, prob_b = self.calcular_probabilidades_poisson(gols_esp_a, gols_esp_b)
            
            # An√°lise de odds (se fornecidas)
            resultado_texto = f"""
{'='*80}
AN√ÅLISE COMPLETA DO CONFRONTO
{'='*80}

üèüÔ∏è  CONFRONTO: {time_a} (Casa) vs {time_b} (Visitante)
üìÖ  Data da An√°lise: {datetime.now().strftime('%d/%m/%Y %H:%M')}

üìä ESTAT√çSTICAS DOS TIMES:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ {time_a:<25} ‚îÇ {time_b:<25} ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Gols/Partida: {dados_a['gols_marcados']:<13.2f} ‚îÇ Gols/Partida: {dados_b['gols_marcados']:<13.2f} ‚îÇ
‚îÇ Gols Sofridos: {dados_a['gols_sofridos']:<12.2f} ‚îÇ Gols Sofridos: {dados_b['gols_sofridos']:<12.2f} ‚îÇ
‚îÇ For√ßa Ofensiva: {dados_a['forca_ofensiva']:<11.2f} ‚îÇ For√ßa Ofensiva: {dados_b['forca_ofensiva']:<11.2f} ‚îÇ
‚îÇ For√ßa Defensiva: {dados_a['forca_defensiva']:<10.2f} ‚îÇ For√ßa Defensiva: {dados_b['forca_defensiva']:<10.2f} ‚îÇ
‚îÇ Liga: {dados_a['liga']:<19} ‚îÇ Liga: {dados_b['liga']:<19} ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚öΩ GOLS ESPERADOS (Modelo de Poisson):
‚Ä¢ {time_a}: {gols_esp_a:.2f} gols
‚Ä¢ {time_b}: {gols_esp_b:.2f} gols
‚Ä¢ Total de gols esperados: {gols_esp_a + gols_esp_b:.2f}
‚Ä¢ Vantagem de casa: {'Aplicada (+15%)' if aplicar_fator_casa else 'N√£o aplicada'}

üéØ PROBABILIDADES CALCULADAS:
‚Ä¢ Vit√≥ria {time_a}: {prob_a:.1%} ({prob_a:.4f})
‚Ä¢ Empate: {prob_empate:.1%} ({prob_empate:.4f})
‚Ä¢ Vit√≥ria {time_b}: {prob_b:.1%} ({prob_b:.4f})

"""
            
            # An√°lise de odds se fornecidas
            try:
                odd_a = float(self.entry_odd_a.get().replace(',', '.'))
                odd_empate = float(self.entry_odd_empate.get().replace(',', '.'))
                odd_b = float(self.entry_odd_b.get().replace(',', '.'))
                
                # Probabilidades impl√≠citas das odds
                prob_impl_a = 1 / odd_a
                prob_impl_empate = 1 / odd_empate
                prob_impl_b = 1 / odd_b
                
                margem_casa = (prob_impl_a + prob_impl_empate + prob_impl_b - 1) * 100
                
                resultado_texto += f"""
üí∞ AN√ÅLISE DE ODDS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Resultado        ‚îÇ Nossa Prob ‚îÇ Odd    ‚îÇ Prob Impl√≠cita ‚îÇ Value Bet?     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Vit√≥ria {time_a:<8} ‚îÇ {prob_a:>8.1%} ‚îÇ {odd_a:>6.2f} ‚îÇ {prob_impl_a:>13.1%} ‚îÇ {"‚úÖ SIM" if prob_a > prob_impl_a else "‚ùå N√ÉO":<14} ‚îÇ
‚îÇ Empate           ‚îÇ {prob_empate:>8.1%} ‚îÇ {odd_empate:>6.2f} ‚îÇ {prob_impl_empate:>13.1%} ‚îÇ {"‚úÖ SIM" if prob_empate > prob_impl_empate else "‚ùå N√ÉO":<14} ‚îÇ
‚îÇ Vit√≥ria {time_b:<8} ‚îÇ {prob_b:>8.1%} ‚îÇ {odd_b:>6.2f} ‚îÇ {prob_impl_b:>13.1%} ‚îÇ {"‚úÖ SIM" if prob_b > prob_impl_b else "‚ùå N√ÉO":<14} ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üìà VANTAGENS PERCENTUAIS:
‚Ä¢ {time_a}: {(prob_a - prob_impl_a) / prob_impl_a * 100:+.1f}%
‚Ä¢ Empate: {(prob_empate - prob_impl_empate) / prob_impl_empate * 100:+.1f}%
‚Ä¢ {time_b}: {(prob_b - prob_impl_b) / prob_impl_b * 100:+.1f}%

üè™ Margem da casa: {margem_casa:.2f}%

"""
                
                # Recomenda√ß√µes
                resultado_texto += "üéØ RECOMENDA√á√ïES:\n"
                
                recomendacoes = []
                if prob_a > prob_impl_a and (prob_a - prob_impl_a) / prob_impl_a > 0.05:
                    vantagem = (prob_a - prob_impl_a) / prob_impl_a * 100
                    recomendacoes.append(f"üî• FORTE: Apostar em vit√≥ria do {time_a} (Vantagem: {vantagem:.1f}%)")
                
                if prob_empate > prob_impl_empate and (prob_empate - prob_impl_empate) / prob_impl_empate > 0.05:
                    vantagem = (prob_empate - prob_impl_empate) / prob_impl_empate * 100
                    recomendacoes.append(f"üî• FORTE: Apostar em empate (Vantagem: {vantagem:.1f}%)")
                
                if prob_b > prob_impl_b and (prob_b - prob_impl_b) / prob_impl_b > 0.05:
                    vantagem = (prob_b - prob_impl_b) / prob_impl_b * 100
                    recomendacoes.append(f"üî• FORTE: Apostar em vit√≥ria do {time_b} (Vantagem: {vantagem:.1f}%)")
                
                if not recomendacoes:
                    resultado_texto += "‚ö†Ô∏è  N√£o foram encontradas apostas com value significativo (>5%)\n"
                    resultado_texto += "   Recomenda-se aguardar melhores oportunidades\n"
                else:
                    for rec in recomendacoes:
                        resultado_texto += f"{rec}\n"
                
            except ValueError:
                resultado_texto += "\nüí° Para an√°lise de value bets, insira as odds da casa de apostas\n"
            
            resultado_texto += f"\n{'='*80}\n"
            
            # Exibir resultado
            self.text_resultados.delete(1.0, tk.END)
            self.text_resultados.insert(1.0, resultado_texto)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no c√°lculo: {str(e)}")
    
    def calcular_aposta_simples(self):
        """Calcula uma aposta simples"""
        try:
            time_a = self.combo_aposta_time_a.get()
            time_b = self.combo_aposta_time_b.get()
            tipo_aposta = self.combo_tipo_aposta.get()
            odd = float(self.entry_aposta_odd.get().replace(',', '.'))
            valor = float(self.entry_valor_aposta.get().replace(',', '.'))
            
            if not all([time_a, time_b, tipo_aposta]):
                messagebox.showwarning("Aviso", "Preencha todos os campos!")
                return
            
            # Calcular probabilidades usando a configura√ß√£o atual do fator casa
            dados_a = self.times_database[time_a]
            dados_b = self.times_database[time_b]
            aplicar_fator_casa = self.var_fator_casa.get()
            
            gols_esp_a, gols_esp_b = self.calcular_gols_esperados(dados_a, dados_b, aplicar_fator_casa)
            prob_a, prob_empate, prob_b = self.calcular_probabilidades_poisson(gols_esp_a, gols_esp_b)
            
            # Mapear probabilidade
            prob_map = {
                "Vit√≥ria A": prob_a,
                "Empate": prob_empate,
                "Vit√≥ria B": prob_b
            }
            
            probabilidade = prob_map[tipo_aposta]
            retorno_potencial = valor * odd
            lucro_potencial = retorno_potencial - valor
            
            # An√°lise de value
            prob_implicita = 1 / odd
            e_value = probabilidade > prob_implicita
            vantagem = (probabilidade - prob_implicita) / prob_implicita * 100
            
            resultado = f"""
AN√ÅLISE DA APOSTA SIMPLES
{'='*50}

üéÆ Confronto: {time_a} vs {time_b}
üéØ Aposta: {tipo_aposta}
üí∞ Valor apostado: R$ {valor:.2f}
üìä Odd: {odd:.2f}
üèüÔ∏è Vantagem de casa: {'Aplicada (+15%)' if aplicar_fator_casa else 'N√£o aplicada'}

üìà PROBABILIDADES:
‚Ä¢ Nossa probabilidade: {probabilidade:.1%}
‚Ä¢ Probabilidade impl√≠cita: {prob_implicita:.1%}
‚Ä¢ {"‚úÖ VALUE BET" if e_value else "‚ùå SEM VALUE"}: {vantagem:+.1f}%

üíµ RETORNOS:
‚Ä¢ Retorno total: R$ {retorno_potencial:.2f}
‚Ä¢ Lucro potencial: R$ {lucro_potencial:.2f}
‚Ä¢ Retorno sobre investimento: {(lucro_potencial/valor)*100:.1f}%

{'='*50}
"""
            
            messagebox.showinfo("Resultado da Aposta", resultado)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no c√°lculo: {str(e)}")
    
    def adicionar_multipla(self):
        """Adiciona aposta √† lista de m√∫ltiplas"""
        try:
            time_a = self.combo_aposta_time_a.get()
            time_b = self.combo_aposta_time_b.get()
            tipo_aposta = self.combo_tipo_aposta.get()
            odd = float(self.entry_aposta_odd.get().replace(',', '.'))
            
            if not all([time_a, time_b, tipo_aposta]):
                messagebox.showwarning("Aviso", "Preencha todos os campos!")
                return
            
            # Calcular probabilidade usando configura√ß√£o atual do fator casa
            dados_a = self.times_database[time_a]
            dados_b = self.times_database[time_b]
            aplicar_fator_casa = self.var_fator_casa.get()
            
            gols_esp_a, gols_esp_b = self.calcular_gols_esperados(dados_a, dados_b, aplicar_fator_casa)
            prob_a, prob_empate, prob_b = self.calcular_probabilidades_poisson(gols_esp_a, gols_esp_b)
            
            prob_map = {
                "Vit√≥ria A": prob_a,
                "Empate": prob_empate,
                "Vit√≥ria B": prob_b
            }
            
            probabilidade = prob_map[tipo_aposta]
            
            # Adicionar √† lista
            aposta = {
                'confronto': f"{time_a} vs {time_b}",
                'tipo': tipo_aposta,
                'odd': odd,
                'probabilidade': probabilidade
            }
            
            self.apostas_ativas.append(aposta)
            
            # Atualizar tree
            self.tree_apostas.insert('', 'end', values=(
                aposta['confronto'],
                aposta['tipo'],
                f"{aposta['odd']:.2f}",
                f"{aposta['probabilidade']:.1%}"
            ))
            
            messagebox.showinfo("Sucesso", "Aposta adicionada √† m√∫ltipla!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar aposta: {str(e)}")
    
    def calcular_multipla(self):
        """Calcula o resultado da aposta m√∫ltipla"""
        try:
            if not self.apostas_ativas:
                messagebox.showwarning("Aviso", "Adicione pelo menos uma aposta!")
                return
            
            valor_total = float(self.entry_valor_multipla.get().replace(',', '.'))
            
            # Calcular odd total e probabilidade combinada
            odd_total = 1
            prob_combinada = 1
            
            for aposta in self.apostas_ativas:
                odd_total *= aposta['odd']
                prob_combinada *= aposta['probabilidade']
            
            retorno_potencial = valor_total * odd_total
            lucro_potencial = retorno_potencial - valor_total
            
            # Exibir resultado
            aplicar_fator_casa = self.var_fator_casa.get()
            resultado_texto = f"""
M√öLTIPLA: {len(self.apostas_ativas)} apostas
üèüÔ∏è Vantagem de casa: {'Aplicada (+15%)' if aplicar_fator_casa else 'N√£o aplicada'}
Odd total: {odd_total:.2f}
Probabilidade: {prob_combinada:.1%}
Retorno: R$ {retorno_potencial:.2f}
Lucro: R$ {lucro_potencial:.2f}
"""
            
            self.label_resultado_multipla.config(text=resultado_texto)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no c√°lculo: {str(e)}")
    
    def limpar_apostas(self):
        """Limpa a lista de apostas"""
        self.apostas_ativas = []
        for item in self.tree_apostas.get_children():
            self.tree_apostas.delete(item)
        self.label_resultado_multipla.config(text="")
    
    def atualizar_estatisticas(self):
        """Atualiza as estat√≠sticas gerais"""
        if not self.times_database:
            self.text_historico.delete(1.0, tk.END)
            self.text_historico.insert(1.0, "Nenhum time cadastrado ainda.")
            return
        
        # Calcular estat√≠sticas
        total_times = len(self.times_database)
        media_gols_marcados = sum(dados['gols_marcados'] for dados in self.times_database.values()) / total_times
        media_gols_sofridos = sum(dados['gols_sofridos'] for dados in self.times_database.values()) / total_times
        
        # Times mais ofensivos e defensivos
        time_mais_ofensivo = max(self.times_database.items(), key=lambda x: x[1]['gols_marcados'])
        time_mais_defensivo = min(self.times_database.items(), key=lambda x: x[1]['gols_sofridos'])
        
        # Ligas representadas
        ligas = set(dados['liga'] for dados in self.times_database.values())
        
        estatisticas = f"""
ESTAT√çSTICAS GERAIS DO BANCO DE DADOS
{'='*60}

üìä RESUMO GERAL:
‚Ä¢ Total de times cadastrados: {total_times}
‚Ä¢ M√©dia de gols marcados: {media_gols_marcados:.2f}
‚Ä¢ M√©dia de gols sofridos: {media_gols_sofridos:.2f}
‚Ä¢ Ligas representadas: {len(ligas)}

üèÜ DESTAQUES:
‚Ä¢ Time mais ofensivo: {time_mais_ofensivo[0]} ({time_mais_ofensivo[1]['gols_marcados']:.2f} gols/jogo)
‚Ä¢ Time mais defensivo: {time_mais_defensivo[0]} ({time_mais_defensivo[1]['gols_sofridos']:.2f} gols sofridos/jogo)

üèüÔ∏è LIGAS CADASTRADAS:
{chr(10).join(f"‚Ä¢ {liga}" for liga in sorted(ligas))}

üìã TODOS OS TIMES:
{'‚îÄ'*80}
"""
        
        # Lista detalhada dos times
        for nome, dados in sorted(self.times_database.items()):
            estatisticas += f"""
{nome}:
  üìà Gols marcados: {dados['gols_marcados']:.2f}/jogo
  üìâ Gols sofridos: {dados['gols_sofridos']:.2f}/jogo
  ‚öîÔ∏è  For√ßa ofensiva: {dados['forca_ofensiva']:.2f}
  üõ°Ô∏è  For√ßa defensiva: {dados['forca_defensiva']:.2f}
  üèÜ Liga: {dados['liga']}
  üìÖ Cadastrado em: {dados.get('data_cadastro', 'N/A')[:10]}
"""
        
        self.text_historico.delete(1.0, tk.END)
        self.text_historico.insert(1.0, estatisticas)
    
    def salvar_dados(self):
        """Salva os dados em arquivo JSON"""
        try:
            # Determinar caminho da pasta data
            pasta_atual = os.path.dirname(os.path.abspath(__file__))
            pasta_pai = os.path.dirname(pasta_atual)
            pasta_data = os.path.join(pasta_pai, 'data')
            arquivo_times = os.path.join(pasta_data, 'times_database.json')
            
            with open(arquivo_times, 'w', encoding='utf-8') as f:
                json.dump(self.times_database, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar dados: {e}")
    
    def carregar_dados(self):
        """Carrega os dados do arquivo JSON"""
        try:
            # Determinar caminho da pasta data
            pasta_atual = os.path.dirname(os.path.abspath(__file__))
            pasta_pai = os.path.dirname(pasta_atual)
            pasta_data = os.path.join(pasta_pai, 'data')
            arquivo_times = os.path.join(pasta_data, 'times_database.json')
            
            if os.path.exists(arquivo_times):
                with open(arquivo_times, 'r', encoding='utf-8') as f:
                    self.times_database = json.load(f)
                self.atualizar_lista_times()
                self.atualizar_comboboxes()
        except Exception as e:
            print(f"Erro ao carregar dados: {e}")
    
    def exportar_dados(self):
        """Exporta os dados para arquivo"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"backup_times_{timestamp}.json"
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.times_database, f, ensure_ascii=False, indent=2)
            
            messagebox.showinfo("Sucesso", f"Dados exportados para {filename}")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar: {str(e)}")
    
    def exportar_relatorio(self):
        """Exporta relat√≥rio completo"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"relatorio_completo_{timestamp}.txt"
            
            content = self.text_historico.get(1.0, tk.END)
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
            
            messagebox.showinfo("Sucesso", f"Relat√≥rio exportado para {filename}")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar relat√≥rio: {str(e)}")
    
    def editar_time(self):
        """Edita o time selecionado"""
        selected = self.tree_times.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione um time para editar!")
            return
        
        item = self.tree_times.item(selected[0])
        nome_time = item['values'][0]
        dados = self.times_database[nome_time]
        
        # Preencher campos com dados atuais
        self.entry_nome.delete(0, tk.END)
        self.entry_nome.insert(0, nome_time)
        
        self.entry_gols_marcados.delete(0, tk.END)
        self.entry_gols_marcados.insert(0, str(dados['gols_marcados']))
        
        self.entry_gols_sofridos.delete(0, tk.END)
        self.entry_gols_sofridos.insert(0, str(dados['gols_sofridos']))
        
        self.entry_liga.delete(0, tk.END)
        self.entry_liga.insert(0, dados['liga'])
    
    # ========== M√âTODOS DA API SOFASCORE ==========
    
    def buscar_times_api(self):
        """Busca times via API SofaScore em thread separada"""
        nome_time = self.entry_busca_time.get().strip()
        
        if not nome_time:
            messagebox.showwarning("Aviso", "Digite o nome de um time para buscar!")
            return
        
        if len(nome_time) < 3:
            messagebox.showwarning("Aviso", "Digite pelo menos 3 caracteres!")
            return
        
        # Desabilitar bot√£o e mostrar status
        self.btn_buscar.config(state='disabled', text="üîÑ Buscando...")
        self.label_status_busca.config(text=f"Buscando '{nome_time}' na API SofaScore...")
        
        # Limpar resultados anteriores
        for item in self.tree_busca.get_children():
            self.tree_busca.delete(item)
        
        # Executar busca em thread separada para n√£o travar a interface
        thread = threading.Thread(target=self._executar_busca_api, args=(nome_time,))
        thread.daemon = True
        thread.start()
    
    def _executar_busca_api(self, nome_time):
        """Executa a busca na API em thread separada"""
        try:
            # Buscar times na API
            times_encontrados = self.api.buscar_e_processar_time(nome_time)
            
            # Atualizar interface na thread principal
            self.root.after(0, self._atualizar_resultados_busca, times_encontrados, nome_time)
            
        except Exception as e:
            # Mostrar erro na thread principal
            self.root.after(0, self._mostrar_erro_busca, str(e))
    
    def _atualizar_resultados_busca(self, times_encontrados, nome_time):
        """Atualiza a interface com os resultados da busca"""
        # Reabilitar bot√£o
        self.btn_buscar.config(state='normal', text="üîç Buscar")
        
        if not times_encontrados:
            self.label_status_busca.config(text=f"Nenhum time encontrado para '{nome_time}'")
            return
        
        # Adicionar resultados √† tabela
        for time in times_encontrados:
            popularidade_formatada = f"{time['popularidade']:,}".replace(',', '.')
            
            self.tree_busca.insert('', 'end', values=(
                time['nome'],
                time['pais'],
                time['liga'],
                f"{time['gols_marcados']:.2f}",
                f"{time['gols_sofridos']:.2f}",
                time['estadio'] or 'N/A',
                popularidade_formatada
            ), tags=(str(time['id_sofascore']),))
        
        # Atualizar status
        total = len(times_encontrados)
        self.label_status_busca.config(text=f"‚úÖ {total} time(s) encontrado(s) para '{nome_time}'")
    
    def _mostrar_erro_busca(self, erro):
        """Mostra erro da busca na interface"""
        self.btn_buscar.config(state='normal', text="üîç Buscar")
        self.label_status_busca.config(text=f"‚ùå Erro na busca: {erro}")
        messagebox.showerror("Erro na API", f"Erro ao buscar times:\n{erro}")
    
    def limpar_busca(self):
        """Limpa os campos e resultados da busca"""
        self.entry_busca_time.delete(0, tk.END)
        
        for item in self.tree_busca.get_children():
            self.tree_busca.delete(item)
        
        self.label_status_busca.config(text="Digite o nome de um time e clique em Buscar")
        self.btn_adicionar_selecionado.config(state='disabled')
    
    def on_selecao_busca(self, event):
        """Callback quando um time √© selecionado na busca"""
        selecao = self.tree_busca.selection()
        if selecao:
            self.btn_adicionar_selecionado.config(state='normal')
        else:
            self.btn_adicionar_selecionado.config(state='disabled')
    
    def adicionar_time_da_busca(self):
        """Adiciona o time selecionado da busca ao banco de dados"""
        selecao = self.tree_busca.selection()
        if not selecao:
            messagebox.showwarning("Aviso", "Selecione um time da lista!")
            return
        
        item = self.tree_busca.item(selecao[0])
        valores = item['values']
        
        nome_time = valores[0]
        
        # Verificar se j√° existe
        if nome_time in self.times_database:
            resposta = messagebox.askyesno(
                "Time j√° existe", 
                f"O time '{nome_time}' j√° est√° cadastrado.\nDeseja atualizar os dados?"
            )
            if not resposta:
                return
        
        # Buscar dados completos do time selecionado
        id_sofascore = item['tags'][0] if item['tags'] else None
        
        if not id_sofascore:
            messagebox.showerror("Erro", "N√£o foi poss√≠vel obter ID do time!")
            return
        
        try:
            # Mostrar progresso
            self.label_status_busca.config(text=f"‚è≥ Adicionando '{nome_time}'...")
            
            # Obter dados completos
            dados_completos = self.api.buscar_e_processar_time(nome_time)
            
            if not dados_completos:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel obter dados completos do time!")
                return
            
            # Encontrar o time correto na lista
            time_selecionado = None
            for time in dados_completos:
                if str(time['id_sofascore']) == id_sofascore:
                    time_selecionado = time
                    break
            
            if not time_selecionado:
                messagebox.showerror("Erro", "Time n√£o encontrado nos dados detalhados!")
                return
            
            # Adicionar ao banco de dados
            self.times_database[nome_time] = {
                'gols_marcados': time_selecionado['gols_marcados'],
                'gols_sofridos': time_selecionado['gols_sofridos'],
                'liga': time_selecionado['liga'],
                'forca_ofensiva': time_selecionado['forca_ofensiva'],
                'forca_defensiva': time_selecionado['forca_defensiva'],
                'data_cadastro': datetime.now().isoformat(),
                'fonte': 'SofaScore API',
                'id_sofascore': time_selecionado['id_sofascore'],
                'pais': time_selecionado['pais'],
                'estadio': time_selecionado['estadio'],
                'tecnico': time_selecionado['tecnico'],
                'popularidade': time_selecionado['popularidade']
            }
            
            # Atualizar interfaces
            self.atualizar_lista_times()
            self.atualizar_comboboxes()
            self.salvar_dados()
            
            # Feedback
            self.label_status_busca.config(text=f"‚úÖ '{nome_time}' adicionado com sucesso!")
            messagebox.showinfo("Sucesso", f"Time '{nome_time}' adicionado com dados da API SofaScore!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar time:\n{str(e)}")
            self.label_status_busca.config(text="‚ùå Erro ao adicionar time")
    
    def ver_detalhes_time(self):
        """Mostra detalhes completos do time selecionado"""
        selecao = self.tree_busca.selection()
        if not selecao:
            messagebox.showwarning("Aviso", "Selecione um time da lista!")
            return
        
        item = self.tree_busca.item(selecao[0])
        valores = item['values']
        id_sofascore = item['tags'][0] if item['tags'] else None
        
        if not id_sofascore:
            messagebox.showerror("Erro", "N√£o foi poss√≠vel obter ID do time!")
            return
        
        try:
            # Buscar dados detalhados
            dados_detalhados = self.api.obter_dados_time(int(id_sofascore))
            estatisticas = self.api.obter_estatisticas_time(int(id_sofascore))
            
            if not dados_detalhados or not estatisticas:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel obter detalhes do time!")
                return
            
            # Criar janela de detalhes
            janela_detalhes = tk.Toplevel(self.root)
            janela_detalhes.title(f"Detalhes - {dados_detalhados['nome']}")
            janela_detalhes.geometry("600x500")
            janela_detalhes.resizable(False, False)
            
            # Texto com detalhes
            texto_detalhes = f"""
üèÜ INFORMA√á√ïES DETALHADAS DO TIME
{'='*60}

üìù DADOS B√ÅSICOS:
‚Ä¢ Nome: {dados_detalhados['nome']}
‚Ä¢ Nome Completo: {dados_detalhados['nome_completo']}
‚Ä¢ Pa√≠s: {dados_detalhados['pais']}
‚Ä¢ Liga Principal: {dados_detalhados['liga_principal']}
‚Ä¢ Liga Atual: {dados_detalhados['liga_atual']}

üèüÔ∏è ESTRUTURA:
‚Ä¢ Est√°dio: {dados_detalhados['estadio']}
‚Ä¢ Capacidade: {dados_detalhados['capacidade_estadio']:,} lugares
‚Ä¢ T√©cnico: {dados_detalhados['tecnico']}

üìä ESTAT√çSTICAS (Temporada 2024/25):
‚Ä¢ Gols por Partida: {estatisticas['gols_marcados']:.2f}
‚Ä¢ Gols Sofridos por Partida: {estatisticas['gols_sofridos']:.2f}
‚Ä¢ For√ßa Ofensiva: {estatisticas['gols_marcados']/estatisticas['media_liga']:.3f}
‚Ä¢ For√ßa Defensiva: {estatisticas['gols_sofridos']/estatisticas['media_liga']:.3f}
‚Ä¢ M√©dia da Liga: {estatisticas['media_liga']:.2f} gols/time/jogo

üåê DADOS ADICIONAIS:
‚Ä¢ Popularidade: {dados_detalhados['popularidade']:,} seguidores
‚Ä¢ ID SofaScore: {dados_detalhados['id']}
‚Ä¢ √öltima Atualiza√ß√£o: {estatisticas['ultima_atualizacao']}

üí° OBSERVA√á√ïES:
‚Ä¢ Os dados estat√≠sticos s√£o estimados baseados na liga
‚Ä¢ Para dados mais precisos, consulte o site oficial do SofaScore
‚Ä¢ As estat√≠sticas s√£o atualizadas regularmente
            """
            
            # Widget de texto com scroll
            text_widget = scrolledtext.ScrolledText(janela_detalhes, wrap=tk.WORD, 
                                                   font=('Consolas', 10), padx=10, pady=10)
            text_widget.pack(fill='both', expand=True, padx=10, pady=10)
            text_widget.insert('1.0', texto_detalhes.strip())
            text_widget.config(state='disabled')
            
            # Bot√£o fechar
            ttk.Button(janela_detalhes, text="Fechar", 
                      command=janela_detalhes.destroy).pack(pady=10)
            
            # Centralizar janela
            janela_detalhes.transient(self.root)
            janela_detalhes.grab_set()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao obter detalhes:\n{str(e)}")

def main():
    """Fun√ß√£o principal"""
    root = tk.Tk()
    app = CalculadoraApostasGUI(root)
    
    # Carregar dados iniciais se existirem
    try:
        # Determinar caminho da pasta data
        pasta_atual = os.path.dirname(os.path.abspath(__file__))
        pasta_pai = os.path.dirname(pasta_atual)
        pasta_data = os.path.join(pasta_pai, 'data')
        arquivo_bet_tabelas = os.path.join(pasta_data, 'Bet tabelas.json')
        
        # Tentar carregar do JSON fornecido
        if os.path.exists(arquivo_bet_tabelas):
            with open(arquivo_bet_tabelas, 'r', encoding='utf-8') as f:
                dados_iniciais = json.load(f)
            
            # # Converter formato antigo para novo
            # if 'media_gols' in dados_iniciais:
            #     for i, jogo in enumerate(dados_iniciais['media_gols']):
            #         if 'TimeA' in jogo and 'TimeB' in jogo:
            #             # Adicionar TimeA
            #             nome_a = f"Time_A_{i+1}"
            #             dados_a = jogo['TimeA']
            #             app.times_database[nome_a] = {
            #                 'gols_marcados': dados_a['gols/partida'],
            #                 'gols_sofridos': dados_a['gols sof/partida'],
            #                 'liga': 'Importado',
            #                 'forca_ofensiva': dados_a['gols/partida'] / 1.2,
            #                 'forca_defensiva': dados_a['gols sof/partida'] / 1.2,
            #                 'data_cadastro': datetime.now().isoformat()
            #             }
                        
            #             # Adicionar TimeB
            #             nome_b = f"Time_B_{i+1}"
            #             dados_b = jogo['TimeB']
            #             app.times_database[nome_b] = {
            #                 'gols_marcados': dados_b['gols/partida'],
            #                 'gols_sofridos': dados_b['gols sof/partida'],
            #                 'liga': 'Importado',
            #                 'forca_ofensiva': dados_b['gols/partida'] / 1.2,
            #                 'forca_defensiva': dados_b['gols sof/partida'] / 1.2,
            #                 'data_cadastro': datetime.now().isoformat()
            #             }
                
                app.atualizar_lista_times()
                app.atualizar_comboboxes()
    except Exception as e:
        print(f"Erro ao carregar dados iniciais: {e}")
    
    root.mainloop()

if __name__ == "__main__":
    main()
